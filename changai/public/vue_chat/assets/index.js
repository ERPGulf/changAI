(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) n(r); new MutationObserver(r => { for (const i of r) if (i.type === "childList") for (const o of i.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o) }).observe(document, { childList: !0, subtree: !0 }); function s(r) { const i = {}; return r.integrity && (i.integrity = r.integrity), r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? i.credentials = "include" : r.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i } function n(r) { if (r.ep) return; r.ep = !0; const i = s(r); fetch(r.href, i) } })();/**
* @vue/shared v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function Os(e) { const t = Object.create(null); for (const s of e.split(",")) t[s] = 1; return s => s in t } const K = {}, tt = [], Te = () => { }, Dr = () => !1, qt = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), As = e => e.startsWith("onUpdate:"), re = Object.assign, Ps = (e, t) => { const s = e.indexOf(t); s > -1 && e.splice(s, 1) }, $r = Object.prototype.hasOwnProperty, D = (e, t) => $r.call(e, t), R = Array.isArray, st = e => zt(e) === "[object Map]", Rn = e => zt(e) === "[object Set]", M = e => typeof e == "function", J = e => typeof e == "string", Ue = e => typeof e == "symbol", V = e => e !== null && typeof e == "object", Mn = e => (V(e) || M(e)) && M(e.then) && M(e.catch), In = Object.prototype.toString, zt = e => In.call(e), Nr = e => zt(e).slice(8, -1), Fn = e => zt(e) === "[object Object]", Rs = e => J(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, pt = Os(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Jt = e => { const t = Object.create(null); return s => t[s] || (t[s] = e(s)) }, jr = /-(\w)/g, Le = Jt(e => e.replace(jr, (t, s) => s ? s.toUpperCase() : "")), Lr = /\B([A-Z])/g, Ze = Jt(e => e.replace(Lr, "-$1").toLowerCase()), Hn = Jt(e => e.charAt(0).toUpperCase() + e.slice(1)), ss = Jt(e => e ? `on${Hn(e)}` : ""), je = (e, t) => !Object.is(e, t), ns = (e, ...t) => { for (let s = 0; s < e.length; s++)e[s](...t) }, ps = (e, t, s, n = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: n, value: s }) }, Br = e => { const t = parseFloat(e); return isNaN(t) ? e : t }; let tn; const Gt = () => tn || (tn = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function Ms(e) { if (R(e)) { const t = {}; for (let s = 0; s < e.length; s++) { const n = e[s], r = J(n) ? Wr(n) : Ms(n); if (r) for (const i in r) t[i] = r[i] } return t } else if (J(e) || V(e)) return e } const Kr = /;(?![^(]*\))/g, Ur = /:([^]+)/, Vr = /\/\*[^]*?\*\//g; function Wr(e) { const t = {}; return e.replace(Vr, "").split(Kr).forEach(s => { if (s) { const n = s.split(Ur); n.length > 1 && (t[n[0].trim()] = n[1].trim()) } }), t } function Ye(e) { let t = ""; if (J(e)) t = e; else if (R(e)) for (let s = 0; s < e.length; s++) { const n = Ye(e[s]); n && (t += n + " ") } else if (V(e)) for (const s in e) e[s] && (t += s + " "); return t.trim() } const qr = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", zr = Os(qr); function Dn(e) { return !!e || e === "" } const $n = e => !!(e && e.__v_isRef === !0), Is = e => J(e) ? e : e == null ? "" : R(e) || V(e) && (e.toString === In || !M(e.toString)) ? $n(e) ? Is(e.value) : JSON.stringify(e, Nn, 2) : String(e), Nn = (e, t) => $n(t) ? Nn(e, t.value) : st(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((s, [n, r], i) => (s[rs(n, i) + " =>"] = r, s), {}) } : Rn(t) ? { [`Set(${t.size})`]: [...t.values()].map(s => rs(s)) } : Ue(t) ? rs(t) : V(t) && !R(t) && !Fn(t) ? String(t) : t, rs = (e, t = "") => { var s; return Ue(e) ? `Symbol(${(s = e.description) != null ? s : t})` : e };/**
* @vue/reactivity v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let le; class Jr { constructor(t = !1) { this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = le, !t && le && (this.index = (le.scopes || (le.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let t, s; if (this.scopes) for (t = 0, s = this.scopes.length; t < s; t++)this.scopes[t].pause(); for (t = 0, s = this.effects.length; t < s; t++)this.effects[t].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let t, s; if (this.scopes) for (t = 0, s = this.scopes.length; t < s; t++)this.scopes[t].resume(); for (t = 0, s = this.effects.length; t < s; t++)this.effects[t].resume() } } run(t) { if (this._active) { const s = le; try { return le = this, t() } finally { le = s } } } on() { ++this._on === 1 && (this.prevScope = le, le = this) } off() { this._on > 0 && --this._on === 0 && (le = this.prevScope, this.prevScope = void 0) } stop(t) { if (this._active) { this._active = !1; let s, n; for (s = 0, n = this.effects.length; s < n; s++)this.effects[s].stop(); for (this.effects.length = 0, s = 0, n = this.cleanups.length; s < n; s++)this.cleanups[s](); if (this.cleanups.length = 0, this.scopes) { for (s = 0, n = this.scopes.length; s < n; s++)this.scopes[s].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !t) { const r = this.parent.scopes.pop(); r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index) } this.parent = void 0 } } } function Gr() { return le } let B; const is = new WeakSet; class jn { constructor(t) { this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, le && le.active && le.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, is.has(this) && (is.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Bn(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, sn(this), Kn(this); const t = B, s = ge; B = this, ge = !0; try { return this.fn() } finally { Un(this), B = t, ge = s, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let t = this.deps; t; t = t.nextDep)Ds(t); this.deps = this.depsTail = void 0, sn(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? is.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { gs(this) && this.run() } get dirty() { return gs(this) } } let Ln = 0, gt, _t; function Bn(e, t = !1) { if (e.flags |= 8, t) { e.next = _t, _t = e; return } e.next = gt, gt = e } function Fs() { Ln++ } function Hs() { if (--Ln > 0) return; if (_t) { let t = _t; for (_t = void 0; t;) { const s = t.next; t.next = void 0, t.flags &= -9, t = s } } let e; for (; gt;) { let t = gt; for (gt = void 0; t;) { const s = t.next; if (t.next = void 0, t.flags &= -9, t.flags & 1) try { t.trigger() } catch (n) { e || (e = n) } t = s } } if (e) throw e } function Kn(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function Un(e) { let t, s = e.depsTail, n = s; for (; n;) { const r = n.prevDep; n.version === -1 ? (n === s && (s = r), Ds(n), Yr(n)) : t = n, n.dep.activeLink = n.prevActiveLink, n.prevActiveLink = void 0, n = r } e.deps = t, e.depsTail = s } function gs(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && (Vn(t.dep.computed) || t.dep.version !== t.version)) return !0; return !!e._dirty } function Vn(e) { if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === xt) || (e.globalVersion = xt, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !gs(e)))) return; e.flags |= 2; const t = e.dep, s = B, n = ge; B = e, ge = !0; try { Kn(e); const r = e.fn(e._value); (t.version === 0 || je(r, e._value)) && (e.flags |= 128, e._value = r, t.version++) } catch (r) { throw t.version++, r } finally { B = s, ge = n, Un(e), e.flags &= -3 } } function Ds(e, t = !1) { const { dep: s, prevSub: n, nextSub: r } = e; if (n && (n.nextSub = r, e.prevSub = void 0), r && (r.prevSub = n, e.nextSub = void 0), s.subs === e && (s.subs = n, !n && s.computed)) { s.computed.flags &= -5; for (let i = s.computed.deps; i; i = i.nextDep)Ds(i, !0) } !t && !--s.sc && s.map && s.map.delete(s.key) } function Yr(e) { const { prevDep: t, nextDep: s } = e; t && (t.nextDep = s, e.prevDep = void 0), s && (s.prevDep = t, e.nextDep = void 0) } let ge = !0; const Wn = []; function Re() { Wn.push(ge), ge = !1 } function Me() { const e = Wn.pop(); ge = e === void 0 ? !0 : e } function sn(e) { const { cleanup: t } = e; if (e.cleanup = void 0, t) { const s = B; B = void 0; try { t() } finally { B = s } } } let xt = 0; class Xr { constructor(t, s) { this.sub = t, this.dep = s, this.version = s.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class $s { constructor(t) { this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0 } track(t) { if (!B || !ge || B === this.computed) return; let s = this.activeLink; if (s === void 0 || s.sub !== B) s = this.activeLink = new Xr(B, this), B.deps ? (s.prevDep = B.depsTail, B.depsTail.nextDep = s, B.depsTail = s) : B.deps = B.depsTail = s, qn(s); else if (s.version === -1 && (s.version = this.version, s.nextDep)) { const n = s.nextDep; n.prevDep = s.prevDep, s.prevDep && (s.prevDep.nextDep = n), s.prevDep = B.depsTail, s.nextDep = void 0, B.depsTail.nextDep = s, B.depsTail = s, B.deps === s && (B.deps = n) } return s } trigger(t) { this.version++, xt++, this.notify(t) } notify(t) { Fs(); try { for (let s = this.subs; s; s = s.prevSub)s.sub.notify() && s.sub.dep.notify() } finally { Hs() } } } function qn(e) { if (e.dep.sc++, e.sub.flags & 4) { const t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let n = t.deps; n; n = n.nextDep)qn(n) } const s = e.dep.subs; s !== e && (e.prevSub = s, s && (s.nextSub = e)), e.dep.subs = e } } const _s = new WeakMap, Xe = Symbol(""), ms = Symbol(""), wt = Symbol(""); function k(e, t, s) { if (ge && B) { let n = _s.get(e); n || _s.set(e, n = new Map); let r = n.get(s); r || (n.set(s, r = new $s), r.map = n, r.key = s), r.track() } } function Pe(e, t, s, n, r, i) { const o = _s.get(e); if (!o) { xt++; return } const c = u => { u && u.trigger() }; if (Fs(), t === "clear") o.forEach(c); else { const u = R(e), h = u && Rs(s); if (u && s === "length") { const a = Number(n); o.forEach((p, S) => { (S === "length" || S === wt || !Ue(S) && S >= a) && c(p) }) } else switch ((s !== void 0 || o.has(void 0)) && c(o.get(s)), h && c(o.get(wt)), t) { case "add": u ? h && c(o.get("length")) : (c(o.get(Xe)), st(e) && c(o.get(ms))); break; case "delete": u || (c(o.get(Xe)), st(e) && c(o.get(ms))); break; case "set": st(e) && c(o.get(Xe)); break } } Hs() } function ke(e) { const t = H(e); return t === e ? t : (k(t, "iterate", wt), he(e) ? t : t.map(X)) } function Yt(e) { return k(e = H(e), "iterate", wt), e } const Zr = { __proto__: null, [Symbol.iterator]() { return os(this, Symbol.iterator, X) }, concat(...e) { return ke(this).concat(...e.map(t => R(t) ? ke(t) : t)) }, entries() { return os(this, "entries", e => (e[1] = X(e[1]), e)) }, every(e, t) { return Oe(this, "every", e, t, void 0, arguments) }, filter(e, t) { return Oe(this, "filter", e, t, s => s.map(X), arguments) }, find(e, t) { return Oe(this, "find", e, t, X, arguments) }, findIndex(e, t) { return Oe(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return Oe(this, "findLast", e, t, X, arguments) }, findLastIndex(e, t) { return Oe(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return Oe(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return ls(this, "includes", e) }, indexOf(...e) { return ls(this, "indexOf", e) }, join(e) { return ke(this).join(e) }, lastIndexOf(...e) { return ls(this, "lastIndexOf", e) }, map(e, t) { return Oe(this, "map", e, t, void 0, arguments) }, pop() { return at(this, "pop") }, push(...e) { return at(this, "push", e) }, reduce(e, ...t) { return nn(this, "reduce", e, t) }, reduceRight(e, ...t) { return nn(this, "reduceRight", e, t) }, shift() { return at(this, "shift") }, some(e, t) { return Oe(this, "some", e, t, void 0, arguments) }, splice(...e) { return at(this, "splice", e) }, toReversed() { return ke(this).toReversed() }, toSorted(e) { return ke(this).toSorted(e) }, toSpliced(...e) { return ke(this).toSpliced(...e) }, unshift(...e) { return at(this, "unshift", e) }, values() { return os(this, "values", X) } }; function os(e, t, s) { const n = Yt(e), r = n[t](); return n !== e && !he(e) && (r._next = r.next, r.next = () => { const i = r._next(); return i.value && (i.value = s(i.value)), i }), r } const kr = Array.prototype; function Oe(e, t, s, n, r, i) { const o = Yt(e), c = o !== e && !he(e), u = o[t]; if (u !== kr[t]) { const p = u.apply(e, i); return c ? X(p) : p } let h = s; o !== e && (c ? h = function (p, S) { return s.call(this, X(p), S, e) } : s.length > 2 && (h = function (p, S) { return s.call(this, p, S, e) })); const a = u.call(o, h, n); return c && r ? r(a) : a } function nn(e, t, s, n) { const r = Yt(e); let i = s; return r !== e && (he(e) ? s.length > 3 && (i = function (o, c, u) { return s.call(this, o, c, u, e) }) : i = function (o, c, u) { return s.call(this, o, X(c), u, e) }), r[t](i, ...n) } function ls(e, t, s) { const n = H(e); k(n, "iterate", wt); const r = n[t](...s); return (r === -1 || r === !1) && Bs(s[0]) ? (s[0] = H(s[0]), n[t](...s)) : r } function at(e, t, s = []) { Re(), Fs(); const n = H(e)[t].apply(e, s); return Hs(), Me(), n } const Qr = Os("__proto__,__v_isRef,__isVue"), zn = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Ue)); function ei(e) { Ue(e) || (e = String(e)); const t = H(this); return k(t, "has", e), t.hasOwnProperty(e) } class Jn { constructor(t = !1, s = !1) { this._isReadonly = t, this._isShallow = s } get(t, s, n) { if (s === "__v_skip") return t.__v_skip; const r = this._isReadonly, i = this._isShallow; if (s === "__v_isReactive") return !r; if (s === "__v_isReadonly") return r; if (s === "__v_isShallow") return i; if (s === "__v_raw") return n === (r ? i ? ui : Zn : i ? Xn : Yn).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(n) ? t : void 0; const o = R(t); if (!r) { let u; if (o && (u = Zr[s])) return u; if (s === "hasOwnProperty") return ei } const c = Reflect.get(t, s, Q(t) ? t : n); return (Ue(s) ? zn.has(s) : Qr(s)) || (r || k(t, "get", s), i) ? c : Q(c) ? o && Rs(s) ? c : c.value : V(c) ? r ? kn(c) : js(c) : c } } class Gn extends Jn { constructor(t = !1) { super(!1, t) } set(t, s, n, r) { let i = t[s]; if (!this._isShallow) { const u = Be(i); if (!he(n) && !Be(n) && (i = H(i), n = H(n)), !R(t) && Q(i) && !Q(n)) return u ? !1 : (i.value = n, !0) } const o = R(t) && Rs(s) ? Number(s) < t.length : D(t, s), c = Reflect.set(t, s, n, Q(t) ? t : r); return t === H(r) && (o ? je(n, i) && Pe(t, "set", s, n) : Pe(t, "add", s, n)), c } deleteProperty(t, s) { const n = D(t, s); t[s]; const r = Reflect.deleteProperty(t, s); return r && n && Pe(t, "delete", s, void 0), r } has(t, s) { const n = Reflect.has(t, s); return (!Ue(s) || !zn.has(s)) && k(t, "has", s), n } ownKeys(t) { return k(t, "iterate", R(t) ? "length" : Xe), Reflect.ownKeys(t) } } class ti extends Jn { constructor(t = !1) { super(!0, t) } set(t, s) { return !0 } deleteProperty(t, s) { return !0 } } const si = new Gn, ni = new ti, ri = new Gn(!0); const bs = e => e, Ft = e => Reflect.getPrototypeOf(e); function ii(e, t, s) { return function (...n) { const r = this.__v_raw, i = H(r), o = st(i), c = e === "entries" || e === Symbol.iterator && o, u = e === "keys" && o, h = r[e](...n), a = s ? bs : t ? Lt : X; return !t && k(i, "iterate", u ? ms : Xe), { next() { const { value: p, done: S } = h.next(); return S ? { value: p, done: S } : { value: c ? [a(p[0]), a(p[1])] : a(p), done: S } }, [Symbol.iterator]() { return this } } } } function Ht(e) { return function (...t) { return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function oi(e, t) { const s = { get(r) { const i = this.__v_raw, o = H(i), c = H(r); e || (je(r, c) && k(o, "get", r), k(o, "get", c)); const { has: u } = Ft(o), h = t ? bs : e ? Lt : X; if (u.call(o, r)) return h(i.get(r)); if (u.call(o, c)) return h(i.get(c)); i !== o && i.get(r) }, get size() { const r = this.__v_raw; return !e && k(H(r), "iterate", Xe), Reflect.get(r, "size", r) }, has(r) { const i = this.__v_raw, o = H(i), c = H(r); return e || (je(r, c) && k(o, "has", r), k(o, "has", c)), r === c ? i.has(r) : i.has(r) || i.has(c) }, forEach(r, i) { const o = this, c = o.__v_raw, u = H(c), h = t ? bs : e ? Lt : X; return !e && k(u, "iterate", Xe), c.forEach((a, p) => r.call(i, h(a), h(p), o)) } }; return re(s, e ? { add: Ht("add"), set: Ht("set"), delete: Ht("delete"), clear: Ht("clear") } : { add(r) { !t && !he(r) && !Be(r) && (r = H(r)); const i = H(this); return Ft(i).has.call(i, r) || (i.add(r), Pe(i, "add", r, r)), this }, set(r, i) { !t && !he(i) && !Be(i) && (i = H(i)); const o = H(this), { has: c, get: u } = Ft(o); let h = c.call(o, r); h || (r = H(r), h = c.call(o, r)); const a = u.call(o, r); return o.set(r, i), h ? je(i, a) && Pe(o, "set", r, i) : Pe(o, "add", r, i), this }, delete(r) { const i = H(this), { has: o, get: c } = Ft(i); let u = o.call(i, r); u || (r = H(r), u = o.call(i, r)), c && c.call(i, r); const h = i.delete(r); return u && Pe(i, "delete", r, void 0), h }, clear() { const r = H(this), i = r.size !== 0, o = r.clear(); return i && Pe(r, "clear", void 0, void 0), o } }), ["keys", "values", "entries", Symbol.iterator].forEach(r => { s[r] = ii(r, e, t) }), s } function Ns(e, t) { const s = oi(e, t); return (n, r, i) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? n : Reflect.get(D(s, r) && r in n ? s : n, r, i) } const li = { get: Ns(!1, !1) }, ci = { get: Ns(!1, !0) }, fi = { get: Ns(!0, !1) }; const Yn = new WeakMap, Xn = new WeakMap, Zn = new WeakMap, ui = new WeakMap; function ai(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function di(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : ai(Nr(e)) } function js(e) { return Be(e) ? e : Ls(e, !1, si, li, Yn) } function hi(e) { return Ls(e, !1, ri, ci, Xn) } function kn(e) { return Ls(e, !0, ni, fi, Zn) } function Ls(e, t, s, n, r) { if (!V(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const i = di(e); if (i === 0) return e; const o = r.get(e); if (o) return o; const c = new Proxy(e, i === 2 ? n : s); return r.set(e, c), c } function nt(e) { return Be(e) ? nt(e.__v_raw) : !!(e && e.__v_isReactive) } function Be(e) { return !!(e && e.__v_isReadonly) } function he(e) { return !!(e && e.__v_isShallow) } function Bs(e) { return e ? !!e.__v_raw : !1 } function H(e) { const t = e && e.__v_raw; return t ? H(t) : e } function pi(e) { return !D(e, "__v_skip") && Object.isExtensible(e) && ps(e, "__v_skip", !0), e } const X = e => V(e) ? js(e) : e, Lt = e => V(e) ? kn(e) : e; function Q(e) { return e ? e.__v_isRef === !0 : !1 } function Qe(e) { return gi(e, !1) } function gi(e, t) { return Q(e) ? e : new _i(e, t) } class _i { constructor(t, s) { this.dep = new $s, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = s ? t : H(t), this._value = s ? t : X(t), this.__v_isShallow = s } get value() { return this.dep.track(), this._value } set value(t) { const s = this._rawValue, n = this.__v_isShallow || he(t) || Be(t); t = n ? t : H(t), je(t, s) && (this._rawValue = t, this._value = n ? t : X(t), this.dep.trigger()) } } function mi(e) { return Q(e) ? e.value : e } const bi = { get: (e, t, s) => t === "__v_raw" ? e : mi(Reflect.get(e, t, s)), set: (e, t, s, n) => { const r = e[t]; return Q(r) && !Q(s) ? (r.value = s, !0) : Reflect.set(e, t, s, n) } }; function Qn(e) { return nt(e) ? e : new Proxy(e, bi) } class yi { constructor(t, s, n) { this.fn = t, this.setter = s, this._value = void 0, this.dep = new $s(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = xt - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !s, this.isSSR = n } notify() { if (this.flags |= 16, !(this.flags & 8) && B !== this) return Bn(this, !0), !0 } get value() { const t = this.dep.track(); return Vn(this), t && (t.version = this.dep.version), this._value } set value(t) { this.setter && this.setter(t) } } function vi(e, t, s = !1) { let n, r; return M(e) ? n = e : (n = e.get, r = e.set), new yi(n, r, s) } const Dt = {}, Bt = new WeakMap; let Ge; function xi(e, t = !1, s = Ge) { if (s) { let n = Bt.get(s); n || Bt.set(s, n = []), n.push(e) } } function wi(e, t, s = K) { const { immediate: n, deep: r, once: i, scheduler: o, augmentJob: c, call: u } = s, h = A => r ? A : he(A) || r === !1 || r === 0 ? Ne(A, 1) : Ne(A); let a, p, S, C, O = !1, I = !1; if (Q(e) ? (p = () => e.value, O = he(e)) : nt(e) ? (p = () => h(e), O = !0) : R(e) ? (I = !0, O = e.some(A => nt(A) || he(A)), p = () => e.map(A => { if (Q(A)) return A.value; if (nt(A)) return h(A); if (M(A)) return u ? u(A, 2) : A() })) : M(e) ? t ? p = u ? () => u(e, 2) : e : p = () => { if (S) { Re(); try { S() } finally { Me() } } const A = Ge; Ge = a; try { return u ? u(e, 3, [C]) : e(C) } finally { Ge = A } } : p = Te, t && r) { const A = p, G = r === !0 ? 1 / 0 : r; p = () => Ne(A(), G) } const Z = Gr(), N = () => { a.stop(), Z && Z.active && Ps(Z.effects, a) }; if (i && t) { const A = t; t = (...G) => { A(...G), N() } } let W = I ? new Array(e.length).fill(Dt) : Dt; const q = A => { if (!(!(a.flags & 1) || !a.dirty && !A)) if (t) { const G = a.run(); if (r || O || (I ? G.some((Fe, _e) => je(Fe, W[_e])) : je(G, W))) { S && S(); const Fe = Ge; Ge = a; try { const _e = [G, W === Dt ? void 0 : I && W[0] === Dt ? [] : W, C]; W = G, u ? u(t, 3, _e) : t(..._e) } finally { Ge = Fe } } } else a.run() }; return c && c(q), a = new jn(p), a.scheduler = o ? () => o(q, !1) : q, C = A => xi(A, !1, a), S = a.onStop = () => { const A = Bt.get(a); if (A) { if (u) u(A, 4); else for (const G of A) G(); Bt.delete(a) } }, t ? n ? q(!0) : W = a.run() : o ? o(q.bind(null, !0), !0) : a.run(), N.pause = a.pause.bind(a), N.resume = a.resume.bind(a), N.stop = N, N } function Ne(e, t = 1 / 0, s) { if (t <= 0 || !V(e) || e.__v_skip || (s = s || new Set, s.has(e))) return e; if (s.add(e), t--, Q(e)) Ne(e.value, t, s); else if (R(e)) for (let n = 0; n < e.length; n++)Ne(e[n], t, s); else if (Rn(e) || st(e)) e.forEach(n => { Ne(n, t, s) }); else if (Fn(e)) { for (const n in e) Ne(e[n], t, s); for (const n of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, n) && Ne(e[n], t, s) } return e }/**
* @vue/runtime-core v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Et(e, t, s, n) { try { return n ? e(...n) : e() } catch (r) { Xt(r, t, s) } } function Ee(e, t, s, n) { if (M(e)) { const r = Et(e, t, s, n); return r && Mn(r) && r.catch(i => { Xt(i, t, s) }), r } if (R(e)) { const r = []; for (let i = 0; i < e.length; i++)r.push(Ee(e[i], t, s, n)); return r } } function Xt(e, t, s, n = !0) { const r = t ? t.vnode : null, { errorHandler: i, throwUnhandledErrorInProduction: o } = t && t.appContext.config || K; if (t) { let c = t.parent; const u = t.proxy, h = `https://vuejs.org/error-reference/#runtime-${s}`; for (; c;) { const a = c.ec; if (a) { for (let p = 0; p < a.length; p++)if (a[p](e, u, h) === !1) return } c = c.parent } if (i) { Re(), Et(i, null, 10, [e, u, h]), Me(); return } } Si(e, s, r, n, o) } function Si(e, t, s, n = !0, r = !1) { if (r) throw e; console.error(e) } const se = []; let we = -1; const rt = []; let De = null, et = 0; const er = Promise.resolve(); let Kt = null; function ys(e) { const t = Kt || er; return e ? t.then(this ? e.bind(this) : e) : t } function Ci(e) { let t = we + 1, s = se.length; for (; t < s;) { const n = t + s >>> 1, r = se[n], i = St(r); i < e || i === e && r.flags & 2 ? t = n + 1 : s = n } return t } function Ks(e) { if (!(e.flags & 1)) { const t = St(e), s = se[se.length - 1]; !s || !(e.flags & 2) && t >= St(s) ? se.push(e) : se.splice(Ci(t), 0, e), e.flags |= 1, tr() } } function tr() { Kt || (Kt = er.then(nr)) } function Ti(e) { R(e) ? rt.push(...e) : De && e.id === -1 ? De.splice(et + 1, 0, e) : e.flags & 1 || (rt.push(e), e.flags |= 1), tr() } function rn(e, t, s = we + 1) { for (; s < se.length; s++) { const n = se[s]; if (n && n.flags & 2) { if (e && n.id !== e.uid) continue; se.splice(s, 1), s--, n.flags & 4 && (n.flags &= -2), n(), n.flags & 4 || (n.flags &= -2) } } } function sr(e) { if (rt.length) { const t = [...new Set(rt)].sort((s, n) => St(s) - St(n)); if (rt.length = 0, De) { De.push(...t); return } for (De = t, et = 0; et < De.length; et++) { const s = De[et]; s.flags & 4 && (s.flags &= -2), s.flags & 8 || s(), s.flags &= -2 } De = null, et = 0 } } const St = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id; function nr(e) { try { for (we = 0; we < se.length; we++) { const t = se[we]; t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), Et(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2)) } } finally { for (; we < se.length; we++) { const t = se[we]; t && (t.flags &= -2) } we = -1, se.length = 0, sr(), Kt = null, (se.length || rt.length) && nr() } } let Ce = null, rr = null; function Ut(e) { const t = Ce; return Ce = e, rr = e && e.type.__scopeId || null, t } function Ei(e, t = Ce, s) { if (!t || e._n) return e; const n = (...r) => { n._d && gn(-1); const i = Ut(t); let o; try { o = e(...r) } finally { Ut(i), n._d && gn(1) } return o }; return n._n = !0, n._c = !0, n._d = !0, n } function ze(e, t, s, n) { const r = e.dirs, i = t && t.dirs; for (let o = 0; o < r.length; o++) { const c = r[o]; i && (c.oldValue = i[o].value); let u = c.dir[n]; u && (Re(), Ee(u, s, 8, [e.el, c, e, t]), Me()) } } const Oi = Symbol("_vte"), Ai = e => e.__isTeleport; function Us(e, t) { e.shapeFlag & 6 && e.component ? (e.transition = t, Us(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function ir(e) { e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0] } function mt(e, t, s, n, r = !1) { if (R(e)) { e.forEach((O, I) => mt(O, t && (R(t) ? t[I] : t), s, n, r)); return } if (bt(n) && !r) { n.shapeFlag & 512 && n.type.__asyncResolved && n.component.subTree.component && mt(e, t, s, n.component.subTree); return } const i = n.shapeFlag & 4 ? Js(n.component) : n.el, o = r ? null : i, { i: c, r: u } = e, h = t && t.r, a = c.refs === K ? c.refs = {} : c.refs, p = c.setupState, S = H(p), C = p === K ? () => !1 : O => D(S, O); if (h != null && h !== u && (J(h) ? (a[h] = null, C(h) && (p[h] = null)) : Q(h) && (h.value = null)), M(u)) Et(u, c, 12, [o, a]); else { const O = J(u), I = Q(u); if (O || I) { const Z = () => { if (e.f) { const N = O ? C(u) ? p[u] : a[u] : u.value; r ? R(N) && Ps(N, i) : R(N) ? N.includes(i) || N.push(i) : O ? (a[u] = [i], C(u) && (p[u] = a[u])) : (u.value = [i], e.k && (a[e.k] = u.value)) } else O ? (a[u] = o, C(u) && (p[u] = o)) : I && (u.value = o, e.k && (a[e.k] = o)) }; o ? (Z.id = -1, ue(Z, s)) : Z() } } } Gt().requestIdleCallback; Gt().cancelIdleCallback; const bt = e => !!e.type.__asyncLoader, or = e => e.type.__isKeepAlive; function Pi(e, t) { lr(e, "a", t) } function Ri(e, t) { lr(e, "da", t) } function lr(e, t, s = ne) { const n = e.__wdc || (e.__wdc = () => { let r = s; for (; r;) { if (r.isDeactivated) return; r = r.parent } return e() }); if (Zt(t, n, s), s) { let r = s.parent; for (; r && r.parent;)or(r.parent.vnode) && Mi(n, t, s, r), r = r.parent } } function Mi(e, t, s, n) { const r = Zt(t, e, n, !0); cr(() => { Ps(n[t], r) }, s) } function Zt(e, t, s = ne, n = !1) { if (s) { const r = s[e] || (s[e] = []), i = t.__weh || (t.__weh = (...o) => { Re(); const c = Ot(s), u = Ee(t, s, e, o); return c(), Me(), u }); return n ? r.unshift(i) : r.push(i), i } } const Ie = e => (t, s = ne) => { (!Tt || e === "sp") && Zt(e, (...n) => t(...n), s) }, Ii = Ie("bm"), Fi = Ie("m"), Hi = Ie("bu"), Di = Ie("u"), $i = Ie("bum"), cr = Ie("um"), Ni = Ie("sp"), ji = Ie("rtg"), Li = Ie("rtc"); function Bi(e, t = ne) { Zt("ec", e, t) } const Ki = Symbol.for("v-ndc"); function on(e, t, s, n) { let r; const i = s, o = R(e); if (o || J(e)) { const c = o && nt(e); let u = !1, h = !1; c && (u = !he(e), h = Be(e), e = Yt(e)), r = new Array(e.length); for (let a = 0, p = e.length; a < p; a++)r[a] = t(u ? h ? Lt(X(e[a])) : X(e[a]) : e[a], a, void 0, i) } else if (typeof e == "number") { r = new Array(e); for (let c = 0; c < e; c++)r[c] = t(c + 1, c, void 0, i) } else if (V(e)) if (e[Symbol.iterator]) r = Array.from(e, (c, u) => t(c, u, void 0, i)); else { const c = Object.keys(e); r = new Array(c.length); for (let u = 0, h = c.length; u < h; u++) { const a = c[u]; r[u] = t(e[a], a, u, i) } } else r = []; return r } const vs = e => e ? Rr(e) ? Js(e) : vs(e.parent) : null, yt = re(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => vs(e.parent), $root: e => vs(e.root), $host: e => e.ce, $emit: e => e.emit, $options: e => ur(e), $forceUpdate: e => e.f || (e.f = () => { Ks(e.update) }), $nextTick: e => e.n || (e.n = ys.bind(e.proxy)), $watch: e => fo.bind(e) }), cs = (e, t) => e !== K && !e.__isScriptSetup && D(e, t), Ui = { get({ _: e }, t) { if (t === "__v_skip") return !0; const { ctx: s, setupState: n, data: r, props: i, accessCache: o, type: c, appContext: u } = e; let h; if (t[0] !== "$") { const C = o[t]; if (C !== void 0) switch (C) { case 1: return n[t]; case 2: return r[t]; case 4: return s[t]; case 3: return i[t] } else { if (cs(n, t)) return o[t] = 1, n[t]; if (r !== K && D(r, t)) return o[t] = 2, r[t]; if ((h = e.propsOptions[0]) && D(h, t)) return o[t] = 3, i[t]; if (s !== K && D(s, t)) return o[t] = 4, s[t]; xs && (o[t] = 0) } } const a = yt[t]; let p, S; if (a) return t === "$attrs" && k(e.attrs, "get", ""), a(e); if ((p = c.__cssModules) && (p = p[t])) return p; if (s !== K && D(s, t)) return o[t] = 4, s[t]; if (S = u.config.globalProperties, D(S, t)) return S[t] }, set({ _: e }, t, s) { const { data: n, setupState: r, ctx: i } = e; return cs(r, t) ? (r[t] = s, !0) : n !== K && D(n, t) ? (n[t] = s, !0) : D(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (i[t] = s, !0) }, has({ _: { data: e, setupState: t, accessCache: s, ctx: n, appContext: r, propsOptions: i } }, o) { let c; return !!s[o] || e !== K && D(e, o) || cs(t, o) || (c = i[0]) && D(c, o) || D(n, o) || D(yt, o) || D(r.config.globalProperties, o) }, defineProperty(e, t, s) { return s.get != null ? e._.accessCache[t] = 0 : D(s, "value") && this.set(e, t, s.value, null), Reflect.defineProperty(e, t, s) } }; function ln(e) { return R(e) ? e.reduce((t, s) => (t[s] = null, t), {}) : e } let xs = !0; function Vi(e) { const t = ur(e), s = e.proxy, n = e.ctx; xs = !1, t.beforeCreate && cn(t.beforeCreate, e, "bc"); const { data: r, computed: i, methods: o, watch: c, provide: u, inject: h, created: a, beforeMount: p, mounted: S, beforeUpdate: C, updated: O, activated: I, deactivated: Z, beforeDestroy: N, beforeUnmount: W, destroyed: q, unmounted: A, render: G, renderTracked: Fe, renderTriggered: _e, errorCaptured: He, serverPrefetch: At, expose: Ve, inheritAttrs: lt, components: Pt, directives: Rt, filters: es } = t; if (h && Wi(h, n, null), o) for (const U in o) { const j = o[U]; M(j) && (n[U] = j.bind(s)) } if (r) { const U = r.call(s, s); V(U) && (e.data = js(U)) } if (xs = !0, i) for (const U in i) { const j = i[U], We = M(j) ? j.bind(s, s) : M(j.get) ? j.get.bind(s, s) : Te, Mt = !M(j) && M(j.set) ? j.set.bind(s) : Te, qe = Mo({ get: We, set: Mt }); Object.defineProperty(n, U, { enumerable: !0, configurable: !0, get: () => qe.value, set: me => qe.value = me }) } if (c) for (const U in c) fr(c[U], n, s, U); if (u) { const U = M(u) ? u.call(s) : u; Reflect.ownKeys(U).forEach(j => { Xi(j, U[j]) }) } a && cn(a, e, "c"); function ee(U, j) { R(j) ? j.forEach(We => U(We.bind(s))) : j && U(j.bind(s)) } if (ee(Ii, p), ee(Fi, S), ee(Hi, C), ee(Di, O), ee(Pi, I), ee(Ri, Z), ee(Bi, He), ee(Li, Fe), ee(ji, _e), ee($i, W), ee(cr, A), ee(Ni, At), R(Ve)) if (Ve.length) { const U = e.exposed || (e.exposed = {}); Ve.forEach(j => { Object.defineProperty(U, j, { get: () => s[j], set: We => s[j] = We, enumerable: !0 }) }) } else e.exposed || (e.exposed = {}); G && e.render === Te && (e.render = G), lt != null && (e.inheritAttrs = lt), Pt && (e.components = Pt), Rt && (e.directives = Rt), At && ir(e) } function Wi(e, t, s = Te) { R(e) && (e = ws(e)); for (const n in e) { const r = e[n]; let i; V(r) ? "default" in r ? i = $t(r.from || n, r.default, !0) : i = $t(r.from || n) : i = $t(r), Q(i) ? Object.defineProperty(t, n, { enumerable: !0, configurable: !0, get: () => i.value, set: o => i.value = o }) : t[n] = i } } function cn(e, t, s) { Ee(R(e) ? e.map(n => n.bind(t.proxy)) : e.bind(t.proxy), t, s) } function fr(e, t, s, n) { let r = n.includes(".") ? Sr(s, n) : () => s[n]; if (J(e)) { const i = t[e]; M(i) && us(r, i) } else if (M(e)) us(r, e.bind(s)); else if (V(e)) if (R(e)) e.forEach(i => fr(i, t, s, n)); else { const i = M(e.handler) ? e.handler.bind(s) : t[e.handler]; M(i) && us(r, i, e) } } function ur(e) { const t = e.type, { mixins: s, extends: n } = t, { mixins: r, optionsCache: i, config: { optionMergeStrategies: o } } = e.appContext, c = i.get(t); let u; return c ? u = c : !r.length && !s && !n ? u = t : (u = {}, r.length && r.forEach(h => Vt(u, h, o, !0)), Vt(u, t, o)), V(t) && i.set(t, u), u } function Vt(e, t, s, n = !1) { const { mixins: r, extends: i } = t; i && Vt(e, i, s, !0), r && r.forEach(o => Vt(e, o, s, !0)); for (const o in t) if (!(n && o === "expose")) { const c = qi[o] || s && s[o]; e[o] = c ? c(e[o], t[o]) : t[o] } return e } const qi = { data: fn, props: un, emits: un, methods: ht, computed: ht, beforeCreate: te, created: te, beforeMount: te, mounted: te, beforeUpdate: te, updated: te, beforeDestroy: te, beforeUnmount: te, destroyed: te, unmounted: te, activated: te, deactivated: te, errorCaptured: te, serverPrefetch: te, components: ht, directives: ht, watch: Ji, provide: fn, inject: zi }; function fn(e, t) { return t ? e ? function () { return re(M(e) ? e.call(this, this) : e, M(t) ? t.call(this, this) : t) } : t : e } function zi(e, t) { return ht(ws(e), ws(t)) } function ws(e) { if (R(e)) { const t = {}; for (let s = 0; s < e.length; s++)t[e[s]] = e[s]; return t } return e } function te(e, t) { return e ? [...new Set([].concat(e, t))] : t } function ht(e, t) { return e ? re(Object.create(null), e, t) : t } function un(e, t) { return e ? R(e) && R(t) ? [...new Set([...e, ...t])] : re(Object.create(null), ln(e), ln(t ?? {})) : t } function Ji(e, t) { if (!e) return t; if (!t) return e; const s = re(Object.create(null), e); for (const n in t) s[n] = te(e[n], t[n]); return s } function ar() { return { app: null, config: { isNativeTag: Dr, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let Gi = 0; function Yi(e, t) { return function (n, r = null) { M(n) || (n = re({}, n)), r != null && !V(r) && (r = null); const i = ar(), o = new WeakSet, c = []; let u = !1; const h = i.app = { _uid: Gi++, _component: n, _props: r, _container: null, _context: i, _instance: null, version: Io, get config() { return i.config }, set config(a) { }, use(a, ...p) { return o.has(a) || (a && M(a.install) ? (o.add(a), a.install(h, ...p)) : M(a) && (o.add(a), a(h, ...p))), h }, mixin(a) { return i.mixins.includes(a) || i.mixins.push(a), h }, component(a, p) { return p ? (i.components[a] = p, h) : i.components[a] }, directive(a, p) { return p ? (i.directives[a] = p, h) : i.directives[a] }, mount(a, p, S) { if (!u) { const C = h._ceVNode || de(n, r); return C.appContext = i, S === !0 ? S = "svg" : S === !1 && (S = void 0), e(C, a, S), u = !0, h._container = a, a.__vue_app__ = h, Js(C.component) } }, onUnmount(a) { c.push(a) }, unmount() { u && (Ee(c, h._instance, 16), e(null, h._container), delete h._container.__vue_app__) }, provide(a, p) { return i.provides[a] = p, h }, runWithContext(a) { const p = it; it = h; try { return a() } finally { it = p } } }; return h } } let it = null; function Xi(e, t) { if (ne) { let s = ne.provides; const n = ne.parent && ne.parent.provides; n === s && (s = ne.provides = Object.create(n)), s[e] = t } } function $t(e, t, s = !1) { const n = To(); if (n || it) { let r = it ? it._context.provides : n ? n.parent == null || n.ce ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : void 0; if (r && e in r) return r[e]; if (arguments.length > 1) return s && M(t) ? t.call(n && n.proxy) : t } } const dr = {}, hr = () => Object.create(dr), pr = e => Object.getPrototypeOf(e) === dr; function Zi(e, t, s, n = !1) { const r = {}, i = hr(); e.propsDefaults = Object.create(null), gr(e, t, r, i); for (const o in e.propsOptions[0]) o in r || (r[o] = void 0); s ? e.props = n ? r : hi(r) : e.type.props ? e.props = r : e.props = i, e.attrs = i } function ki(e, t, s, n) { const { props: r, attrs: i, vnode: { patchFlag: o } } = e, c = H(r), [u] = e.propsOptions; let h = !1; if ((n || o > 0) && !(o & 16)) { if (o & 8) { const a = e.vnode.dynamicProps; for (let p = 0; p < a.length; p++) { let S = a[p]; if (kt(e.emitsOptions, S)) continue; const C = t[S]; if (u) if (D(i, S)) C !== i[S] && (i[S] = C, h = !0); else { const O = Le(S); r[O] = Ss(u, c, O, C, e, !1) } else C !== i[S] && (i[S] = C, h = !0) } } } else { gr(e, t, r, i) && (h = !0); let a; for (const p in c) (!t || !D(t, p) && ((a = Ze(p)) === p || !D(t, a))) && (u ? s && (s[p] !== void 0 || s[a] !== void 0) && (r[p] = Ss(u, c, p, void 0, e, !0)) : delete r[p]); if (i !== c) for (const p in i) (!t || !D(t, p)) && (delete i[p], h = !0) } h && Pe(e.attrs, "set", "") } function gr(e, t, s, n) { const [r, i] = e.propsOptions; let o = !1, c; if (t) for (let u in t) { if (pt(u)) continue; const h = t[u]; let a; r && D(r, a = Le(u)) ? !i || !i.includes(a) ? s[a] = h : (c || (c = {}))[a] = h : kt(e.emitsOptions, u) || (!(u in n) || h !== n[u]) && (n[u] = h, o = !0) } if (i) { const u = H(s), h = c || K; for (let a = 0; a < i.length; a++) { const p = i[a]; s[p] = Ss(r, u, p, h[p], e, !D(h, p)) } } return o } function Ss(e, t, s, n, r, i) { const o = e[s]; if (o != null) { const c = D(o, "default"); if (c && n === void 0) { const u = o.default; if (o.type !== Function && !o.skipFactory && M(u)) { const { propsDefaults: h } = r; if (s in h) n = h[s]; else { const a = Ot(r); n = h[s] = u.call(null, t), a() } } else n = u; r.ce && r.ce._setProp(s, n) } o[0] && (i && !c ? n = !1 : o[1] && (n === "" || n === Ze(s)) && (n = !0)) } return n } const Qi = new WeakMap; function _r(e, t, s = !1) { const n = s ? Qi : t.propsCache, r = n.get(e); if (r) return r; const i = e.props, o = {}, c = []; let u = !1; if (!M(e)) { const a = p => { u = !0; const [S, C] = _r(p, t, !0); re(o, S), C && c.push(...C) }; !s && t.mixins.length && t.mixins.forEach(a), e.extends && a(e.extends), e.mixins && e.mixins.forEach(a) } if (!i && !u) return V(e) && n.set(e, tt), tt; if (R(i)) for (let a = 0; a < i.length; a++) { const p = Le(i[a]); an(p) && (o[p] = K) } else if (i) for (const a in i) { const p = Le(a); if (an(p)) { const S = i[a], C = o[p] = R(S) || M(S) ? { type: S } : re({}, S), O = C.type; let I = !1, Z = !0; if (R(O)) for (let N = 0; N < O.length; ++N) { const W = O[N], q = M(W) && W.name; if (q === "Boolean") { I = !0; break } else q === "String" && (Z = !1) } else I = M(O) && O.name === "Boolean"; C[0] = I, C[1] = Z, (I || D(C, "default")) && c.push(p) } } const h = [o, c]; return V(e) && n.set(e, h), h } function an(e) { return e[0] !== "$" && !pt(e) } const Vs = e => e === "_" || e === "__" || e === "_ctx" || e === "$stable", Ws = e => R(e) ? e.map(Se) : [Se(e)], eo = (e, t, s) => { if (t._n) return t; const n = Ei((...r) => Ws(t(...r)), s); return n._c = !1, n }, mr = (e, t, s) => { const n = e._ctx; for (const r in e) { if (Vs(r)) continue; const i = e[r]; if (M(i)) t[r] = eo(r, i, n); else if (i != null) { const o = Ws(i); t[r] = () => o } } }, br = (e, t) => { const s = Ws(t); e.slots.default = () => s }, yr = (e, t, s) => { for (const n in t) (s || !Vs(n)) && (e[n] = t[n]) }, to = (e, t, s) => { const n = e.slots = hr(); if (e.vnode.shapeFlag & 32) { const r = t.__; r && ps(n, "__", r, !0); const i = t._; i ? (yr(n, t, s), s && ps(n, "_", i, !0)) : mr(t, n) } else t && br(e, t) }, so = (e, t, s) => { const { vnode: n, slots: r } = e; let i = !0, o = K; if (n.shapeFlag & 32) { const c = t._; c ? s && c === 1 ? i = !1 : yr(r, t, s) : (i = !t.$stable, mr(t, r)), o = t } else t && (br(e, t), o = { default: 1 }); if (i) for (const c in r) !Vs(c) && o[c] == null && delete r[c] }, ue = mo; function no(e) { return ro(e) } function ro(e, t) { const s = Gt(); s.__VUE__ = !0; const { insert: n, remove: r, patchProp: i, createElement: o, createText: c, createComment: u, setText: h, setElementText: a, parentNode: p, nextSibling: S, setScopeId: C = Te, insertStaticContent: O } = e, I = (l, f, d, m = null, g = null, _ = null, x = void 0, v = null, y = !!f.dynamicChildren) => { if (l === f) return; l && !dt(l, f) && (m = It(l), me(l, g, _, !0), l = null), f.patchFlag === -2 && (y = !1, f.dynamicChildren = null); const { type: b, ref: E, shapeFlag: w } = f; switch (b) { case Qt: Z(l, f, d, m); break; case Ke: N(l, f, d, m); break; case as: l == null && W(f, d, m, x); break; case pe: Pt(l, f, d, m, g, _, x, v, y); break; default: w & 1 ? G(l, f, d, m, g, _, x, v, y) : w & 6 ? Rt(l, f, d, m, g, _, x, v, y) : (w & 64 || w & 128) && b.process(l, f, d, m, g, _, x, v, y, ft) }E != null && g ? mt(E, l && l.ref, _, f || l, !f) : E == null && l && l.ref != null && mt(l.ref, null, _, l, !0) }, Z = (l, f, d, m) => { if (l == null) n(f.el = c(f.children), d, m); else { const g = f.el = l.el; f.children !== l.children && h(g, f.children) } }, N = (l, f, d, m) => { l == null ? n(f.el = u(f.children || ""), d, m) : f.el = l.el }, W = (l, f, d, m) => { [l.el, l.anchor] = O(l.children, f, d, m, l.el, l.anchor) }, q = ({ el: l, anchor: f }, d, m) => { let g; for (; l && l !== f;)g = S(l), n(l, d, m), l = g; n(f, d, m) }, A = ({ el: l, anchor: f }) => { let d; for (; l && l !== f;)d = S(l), r(l), l = d; r(f) }, G = (l, f, d, m, g, _, x, v, y) => { f.type === "svg" ? x = "svg" : f.type === "math" && (x = "mathml"), l == null ? Fe(f, d, m, g, _, x, v, y) : At(l, f, g, _, x, v, y) }, Fe = (l, f, d, m, g, _, x, v) => { let y, b; const { props: E, shapeFlag: w, transition: T, dirs: P } = l; if (y = l.el = o(l.type, _, E && E.is, E), w & 8 ? a(y, l.children) : w & 16 && He(l.children, y, null, m, g, fs(l, _), x, v), P && ze(l, null, m, "created"), _e(y, l, l.scopeId, x, m), E) { for (const L in E) L !== "value" && !pt(L) && i(y, L, null, E[L], _, m); "value" in E && i(y, "value", null, E.value, _), (b = E.onVnodeBeforeMount) && xe(b, m, l) } P && ze(l, null, m, "beforeMount"); const F = io(g, T); F && T.beforeEnter(y), n(y, f, d), ((b = E && E.onVnodeMounted) || F || P) && ue(() => { b && xe(b, m, l), F && T.enter(y), P && ze(l, null, m, "mounted") }, g) }, _e = (l, f, d, m, g) => { if (d && C(l, d), m) for (let _ = 0; _ < m.length; _++)C(l, m[_]); if (g) { let _ = g.subTree; if (f === _ || Tr(_.type) && (_.ssContent === f || _.ssFallback === f)) { const x = g.vnode; _e(l, x, x.scopeId, x.slotScopeIds, g.parent) } } }, He = (l, f, d, m, g, _, x, v, y = 0) => { for (let b = y; b < l.length; b++) { const E = l[b] = v ? $e(l[b]) : Se(l[b]); I(null, E, f, d, m, g, _, x, v) } }, At = (l, f, d, m, g, _, x) => { const v = f.el = l.el; let { patchFlag: y, dynamicChildren: b, dirs: E } = f; y |= l.patchFlag & 16; const w = l.props || K, T = f.props || K; let P; if (d && Je(d, !1), (P = T.onVnodeBeforeUpdate) && xe(P, d, f, l), E && ze(f, l, d, "beforeUpdate"), d && Je(d, !0), (w.innerHTML && T.innerHTML == null || w.textContent && T.textContent == null) && a(v, ""), b ? Ve(l.dynamicChildren, b, v, d, m, fs(f, g), _) : x || j(l, f, v, null, d, m, fs(f, g), _, !1), y > 0) { if (y & 16) lt(v, w, T, d, g); else if (y & 2 && w.class !== T.class && i(v, "class", null, T.class, g), y & 4 && i(v, "style", w.style, T.style, g), y & 8) { const F = f.dynamicProps; for (let L = 0; L < F.length; L++) { const $ = F[L], ie = w[$], oe = T[$]; (oe !== ie || $ === "value") && i(v, $, ie, oe, g, d) } } y & 1 && l.children !== f.children && a(v, f.children) } else !x && b == null && lt(v, w, T, d, g); ((P = T.onVnodeUpdated) || E) && ue(() => { P && xe(P, d, f, l), E && ze(f, l, d, "updated") }, m) }, Ve = (l, f, d, m, g, _, x) => { for (let v = 0; v < f.length; v++) { const y = l[v], b = f[v], E = y.el && (y.type === pe || !dt(y, b) || y.shapeFlag & 198) ? p(y.el) : d; I(y, b, E, null, m, g, _, x, !0) } }, lt = (l, f, d, m, g) => { if (f !== d) { if (f !== K) for (const _ in f) !pt(_) && !(_ in d) && i(l, _, f[_], null, g, m); for (const _ in d) { if (pt(_)) continue; const x = d[_], v = f[_]; x !== v && _ !== "value" && i(l, _, v, x, g, m) } "value" in d && i(l, "value", f.value, d.value, g) } }, Pt = (l, f, d, m, g, _, x, v, y) => { const b = f.el = l ? l.el : c(""), E = f.anchor = l ? l.anchor : c(""); let { patchFlag: w, dynamicChildren: T, slotScopeIds: P } = f; P && (v = v ? v.concat(P) : P), l == null ? (n(b, d, m), n(E, d, m), He(f.children || [], d, E, g, _, x, v, y)) : w > 0 && w & 64 && T && l.dynamicChildren ? (Ve(l.dynamicChildren, T, d, g, _, x, v), (f.key != null || g && f === g.subTree) && vr(l, f, !0)) : j(l, f, d, E, g, _, x, v, y) }, Rt = (l, f, d, m, g, _, x, v, y) => { f.slotScopeIds = v, l == null ? f.shapeFlag & 512 ? g.ctx.activate(f, d, m, x, y) : es(f, d, m, g, _, x, y) : Ys(l, f, y) }, es = (l, f, d, m, g, _, x) => { const v = l.component = Co(l, m, g); if (or(l) && (v.ctx.renderer = ft), Eo(v, !1, x), v.asyncDep) { if (g && g.registerDep(v, ee, x), !l.el) { const y = v.subTree = de(Ke); N(null, y, f, d), l.placeholder = y.el } } else ee(v, l, f, d, g, _, x) }, Ys = (l, f, d) => { const m = f.component = l.component; if (go(l, f, d)) if (m.asyncDep && !m.asyncResolved) { U(m, f, d); return } else m.next = f, m.update(); else f.el = l.el, m.vnode = f }, ee = (l, f, d, m, g, _, x) => { const v = () => { if (l.isMounted) { let { next: w, bu: T, u: P, parent: F, vnode: L } = l; { const ye = xr(l); if (ye) { w && (w.el = L.el, U(l, w, x)), ye.asyncDep.then(() => { l.isUnmounted || v() }); return } } let $ = w, ie; Je(l, !1), w ? (w.el = L.el, U(l, w, x)) : w = L, T && ns(T), (ie = w.props && w.props.onVnodeBeforeUpdate) && xe(ie, F, w, L), Je(l, !0); const oe = hn(l), be = l.subTree; l.subTree = oe, I(be, oe, p(be.el), It(be), l, g, _), w.el = oe.el, $ === null && _o(l, oe.el), P && ue(P, g), (ie = w.props && w.props.onVnodeUpdated) && ue(() => xe(ie, F, w, L), g) } else { let w; const { el: T, props: P } = f, { bm: F, m: L, parent: $, root: ie, type: oe } = l, be = bt(f); Je(l, !1), F && ns(F), !be && (w = P && P.onVnodeBeforeMount) && xe(w, $, f), Je(l, !0); { ie.ce && ie.ce._def.shadowRoot !== !1 && ie.ce._injectChildStyle(oe); const ye = l.subTree = hn(l); I(null, ye, d, m, l, g, _), f.el = ye.el } if (L && ue(L, g), !be && (w = P && P.onVnodeMounted)) { const ye = f; ue(() => xe(w, $, ye), g) } (f.shapeFlag & 256 || $ && bt($.vnode) && $.vnode.shapeFlag & 256) && l.a && ue(l.a, g), l.isMounted = !0, f = d = m = null } }; l.scope.on(); const y = l.effect = new jn(v); l.scope.off(); const b = l.update = y.run.bind(y), E = l.job = y.runIfDirty.bind(y); E.i = l, E.id = l.uid, y.scheduler = () => Ks(E), Je(l, !0), b() }, U = (l, f, d) => { f.component = l; const m = l.vnode.props; l.vnode = f, l.next = null, ki(l, f.props, m, d), so(l, f.children, d), Re(), rn(l), Me() }, j = (l, f, d, m, g, _, x, v, y = !1) => { const b = l && l.children, E = l ? l.shapeFlag : 0, w = f.children, { patchFlag: T, shapeFlag: P } = f; if (T > 0) { if (T & 128) { Mt(b, w, d, m, g, _, x, v, y); return } else if (T & 256) { We(b, w, d, m, g, _, x, v, y); return } } P & 8 ? (E & 16 && ct(b, g, _), w !== b && a(d, w)) : E & 16 ? P & 16 ? Mt(b, w, d, m, g, _, x, v, y) : ct(b, g, _, !0) : (E & 8 && a(d, ""), P & 16 && He(w, d, m, g, _, x, v, y)) }, We = (l, f, d, m, g, _, x, v, y) => { l = l || tt, f = f || tt; const b = l.length, E = f.length, w = Math.min(b, E); let T; for (T = 0; T < w; T++) { const P = f[T] = y ? $e(f[T]) : Se(f[T]); I(l[T], P, d, null, g, _, x, v, y) } b > E ? ct(l, g, _, !0, !1, w) : He(f, d, m, g, _, x, v, y, w) }, Mt = (l, f, d, m, g, _, x, v, y) => { let b = 0; const E = f.length; let w = l.length - 1, T = E - 1; for (; b <= w && b <= T;) { const P = l[b], F = f[b] = y ? $e(f[b]) : Se(f[b]); if (dt(P, F)) I(P, F, d, null, g, _, x, v, y); else break; b++ } for (; b <= w && b <= T;) { const P = l[w], F = f[T] = y ? $e(f[T]) : Se(f[T]); if (dt(P, F)) I(P, F, d, null, g, _, x, v, y); else break; w--, T-- } if (b > w) { if (b <= T) { const P = T + 1, F = P < E ? f[P].el : m; for (; b <= T;)I(null, f[b] = y ? $e(f[b]) : Se(f[b]), d, F, g, _, x, v, y), b++ } } else if (b > T) for (; b <= w;)me(l[b], g, _, !0), b++; else { const P = b, F = b, L = new Map; for (b = F; b <= T; b++) { const fe = f[b] = y ? $e(f[b]) : Se(f[b]); fe.key != null && L.set(fe.key, b) } let $, ie = 0; const oe = T - F + 1; let be = !1, ye = 0; const ut = new Array(oe); for (b = 0; b < oe; b++)ut[b] = 0; for (b = P; b <= w; b++) { const fe = l[b]; if (ie >= oe) { me(fe, g, _, !0); continue } let ve; if (fe.key != null) ve = L.get(fe.key); else for ($ = F; $ <= T; $++)if (ut[$ - F] === 0 && dt(fe, f[$])) { ve = $; break } ve === void 0 ? me(fe, g, _, !0) : (ut[ve - F] = b + 1, ve >= ye ? ye = ve : be = !0, I(fe, f[ve], d, null, g, _, x, v, y), ie++) } const ks = be ? oo(ut) : tt; for ($ = ks.length - 1, b = oe - 1; b >= 0; b--) { const fe = F + b, ve = f[fe], Qs = f[fe + 1], en = fe + 1 < E ? Qs.el || Qs.placeholder : m; ut[b] === 0 ? I(null, ve, d, en, g, _, x, v, y) : be && ($ < 0 || b !== ks[$] ? qe(ve, d, en, 2) : $--) } } }, qe = (l, f, d, m, g = null) => { const { el: _, type: x, transition: v, children: y, shapeFlag: b } = l; if (b & 6) { qe(l.component.subTree, f, d, m); return } if (b & 128) { l.suspense.move(f, d, m); return } if (b & 64) { x.move(l, f, d, ft); return } if (x === pe) { n(_, f, d); for (let w = 0; w < y.length; w++)qe(y[w], f, d, m); n(l.anchor, f, d); return } if (x === as) { q(l, f, d); return } if (m !== 2 && b & 1 && v) if (m === 0) v.beforeEnter(_), n(_, f, d), ue(() => v.enter(_), g); else { const { leave: w, delayLeave: T, afterLeave: P } = v, F = () => { l.ctx.isUnmounted ? r(_) : n(_, f, d) }, L = () => { w(_, () => { F(), P && P() }) }; T ? T(_, F, L) : L() } else n(_, f, d) }, me = (l, f, d, m = !1, g = !1) => { const { type: _, props: x, ref: v, children: y, dynamicChildren: b, shapeFlag: E, patchFlag: w, dirs: T, cacheIndex: P } = l; if (w === -2 && (g = !1), v != null && (Re(), mt(v, null, d, l, !0), Me()), P != null && (f.renderCache[P] = void 0), E & 256) { f.ctx.deactivate(l); return } const F = E & 1 && T, L = !bt(l); let $; if (L && ($ = x && x.onVnodeBeforeUnmount) && xe($, f, l), E & 6) Hr(l.component, d, m); else { if (E & 128) { l.suspense.unmount(d, m); return } F && ze(l, null, f, "beforeUnmount"), E & 64 ? l.type.remove(l, f, d, ft, m) : b && !b.hasOnce && (_ !== pe || w > 0 && w & 64) ? ct(b, f, d, !1, !0) : (_ === pe && w & 384 || !g && E & 16) && ct(y, f, d), m && Xs(l) } (L && ($ = x && x.onVnodeUnmounted) || F) && ue(() => { $ && xe($, f, l), F && ze(l, null, f, "unmounted") }, d) }, Xs = l => { const { type: f, el: d, anchor: m, transition: g } = l; if (f === pe) { Fr(d, m); return } if (f === as) { A(l); return } const _ = () => { r(d), g && !g.persisted && g.afterLeave && g.afterLeave() }; if (l.shapeFlag & 1 && g && !g.persisted) { const { leave: x, delayLeave: v } = g, y = () => x(d, _); v ? v(l.el, _, y) : y() } else _() }, Fr = (l, f) => { let d; for (; l !== f;)d = S(l), r(l), l = d; r(f) }, Hr = (l, f, d) => { const { bum: m, scope: g, job: _, subTree: x, um: v, m: y, a: b, parent: E, slots: { __: w } } = l; dn(y), dn(b), m && ns(m), E && R(w) && w.forEach(T => { E.renderCache[T] = void 0 }), g.stop(), _ && (_.flags |= 8, me(x, l, f, d)), v && ue(v, f), ue(() => { l.isUnmounted = !0 }, f), f && f.pendingBranch && !f.isUnmounted && l.asyncDep && !l.asyncResolved && l.suspenseId === f.pendingId && (f.deps--, f.deps === 0 && f.resolve()) }, ct = (l, f, d, m = !1, g = !1, _ = 0) => { for (let x = _; x < l.length; x++)me(l[x], f, d, m, g) }, It = l => { if (l.shapeFlag & 6) return It(l.component.subTree); if (l.shapeFlag & 128) return l.suspense.next(); const f = S(l.anchor || l.el), d = f && f[Oi]; return d ? S(d) : f }; let ts = !1; const Zs = (l, f, d) => { l == null ? f._vnode && me(f._vnode, null, null, !0) : I(f._vnode || null, l, f, null, null, null, d), f._vnode = l, ts || (ts = !0, rn(), sr(), ts = !1) }, ft = { p: I, um: me, m: qe, r: Xs, mt: es, mc: He, pc: j, pbc: Ve, n: It, o: e }; return { render: Zs, hydrate: void 0, createApp: Yi(Zs) } } function fs({ type: e, props: t }, s) { return s === "svg" && e === "foreignObject" || s === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : s } function Je({ effect: e, job: t }, s) { s ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5) } function io(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function vr(e, t, s = !1) { const n = e.children, r = t.children; if (R(n) && R(r)) for (let i = 0; i < n.length; i++) { const o = n[i]; let c = r[i]; c.shapeFlag & 1 && !c.dynamicChildren && ((c.patchFlag <= 0 || c.patchFlag === 32) && (c = r[i] = $e(r[i]), c.el = o.el), !s && c.patchFlag !== -2 && vr(o, c)), c.type === Qt && (c.el = o.el), c.type === Ke && !c.el && (c.el = o.el) } } function oo(e) { const t = e.slice(), s = [0]; let n, r, i, o, c; const u = e.length; for (n = 0; n < u; n++) { const h = e[n]; if (h !== 0) { if (r = s[s.length - 1], e[r] < h) { t[n] = r, s.push(n); continue } for (i = 0, o = s.length - 1; i < o;)c = i + o >> 1, e[s[c]] < h ? i = c + 1 : o = c; h < e[s[i]] && (i > 0 && (t[n] = s[i - 1]), s[i] = n) } } for (i = s.length, o = s[i - 1]; i-- > 0;)s[i] = o, o = t[o]; return s } function xr(e) { const t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : xr(t) } function dn(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8 } const lo = Symbol.for("v-scx"), co = () => $t(lo); function us(e, t, s) { return wr(e, t, s) } function wr(e, t, s = K) { const { immediate: n, deep: r, flush: i, once: o } = s, c = re({}, s), u = t && n || !t && i !== "post"; let h; if (Tt) { if (i === "sync") { const C = co(); h = C.__watcherHandles || (C.__watcherHandles = []) } else if (!u) { const C = () => { }; return C.stop = Te, C.resume = Te, C.pause = Te, C } } const a = ne; c.call = (C, O, I) => Ee(C, a, O, I); let p = !1; i === "post" ? c.scheduler = C => { ue(C, a && a.suspense) } : i !== "sync" && (p = !0, c.scheduler = (C, O) => { O ? C() : Ks(C) }), c.augmentJob = C => { t && (C.flags |= 4), p && (C.flags |= 2, a && (C.id = a.uid, C.i = a)) }; const S = wi(e, t, c); return Tt && (h ? h.push(S) : u && S()), S } function fo(e, t, s) { const n = this.proxy, r = J(e) ? e.includes(".") ? Sr(n, e) : () => n[e] : e.bind(n, n); let i; M(t) ? i = t : (i = t.handler, s = t); const o = Ot(this), c = wr(r, i.bind(n), s); return o(), c } function Sr(e, t) { const s = t.split("."); return () => { let n = e; for (let r = 0; r < s.length && n; r++)n = n[s[r]]; return n } } const uo = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${Le(t)}Modifiers`] || e[`${Ze(t)}Modifiers`]; function ao(e, t, ...s) { if (e.isUnmounted) return; const n = e.vnode.props || K; let r = s; const i = t.startsWith("update:"), o = i && uo(n, t.slice(7)); o && (o.trim && (r = s.map(a => J(a) ? a.trim() : a)), o.number && (r = s.map(Br))); let c, u = n[c = ss(t)] || n[c = ss(Le(t))]; !u && i && (u = n[c = ss(Ze(t))]), u && Ee(u, e, 6, r); const h = n[c + "Once"]; if (h) { if (!e.emitted) e.emitted = {}; else if (e.emitted[c]) return; e.emitted[c] = !0, Ee(h, e, 6, r) } } function Cr(e, t, s = !1) { const n = t.emitsCache, r = n.get(e); if (r !== void 0) return r; const i = e.emits; let o = {}, c = !1; if (!M(e)) { const u = h => { const a = Cr(h, t, !0); a && (c = !0, re(o, a)) }; !s && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u) } return !i && !c ? (V(e) && n.set(e, null), null) : (R(i) ? i.forEach(u => o[u] = null) : re(o, i), V(e) && n.set(e, o), o) } function kt(e, t) { return !e || !qt(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), D(e, t[0].toLowerCase() + t.slice(1)) || D(e, Ze(t)) || D(e, t)) } function hn(e) { const { type: t, vnode: s, proxy: n, withProxy: r, propsOptions: [i], slots: o, attrs: c, emit: u, render: h, renderCache: a, props: p, data: S, setupState: C, ctx: O, inheritAttrs: I } = e, Z = Ut(e); let N, W; try { if (s.shapeFlag & 4) { const A = r || n, G = A; N = Se(h.call(G, A, a, p, C, S, O)), W = c } else { const A = t; N = Se(A.length > 1 ? A(p, { attrs: c, slots: o, emit: u }) : A(p, null)), W = t.props ? c : ho(c) } } catch (A) { vt.length = 0, Xt(A, e, 1), N = de(Ke) } let q = N; if (W && I !== !1) { const A = Object.keys(W), { shapeFlag: G } = q; A.length && G & 7 && (i && A.some(As) && (W = po(W, i)), q = ot(q, W, !1, !0)) } return s.dirs && (q = ot(q, null, !1, !0), q.dirs = q.dirs ? q.dirs.concat(s.dirs) : s.dirs), s.transition && Us(q, s.transition), N = q, Ut(Z), N } const ho = e => { let t; for (const s in e) (s === "class" || s === "style" || qt(s)) && ((t || (t = {}))[s] = e[s]); return t }, po = (e, t) => { const s = {}; for (const n in e) (!As(n) || !(n.slice(9) in t)) && (s[n] = e[n]); return s }; function go(e, t, s) { const { props: n, children: r, component: i } = e, { props: o, children: c, patchFlag: u } = t, h = i.emitsOptions; if (t.dirs || t.transition) return !0; if (s && u >= 0) { if (u & 1024) return !0; if (u & 16) return n ? pn(n, o, h) : !!o; if (u & 8) { const a = t.dynamicProps; for (let p = 0; p < a.length; p++) { const S = a[p]; if (o[S] !== n[S] && !kt(h, S)) return !0 } } } else return (r || c) && (!c || !c.$stable) ? !0 : n === o ? !1 : n ? o ? pn(n, o, h) : !0 : !!o; return !1 } function pn(e, t, s) { const n = Object.keys(t); if (n.length !== Object.keys(e).length) return !0; for (let r = 0; r < n.length; r++) { const i = n[r]; if (t[i] !== e[i] && !kt(s, i)) return !0 } return !1 } function _o({ vnode: e, parent: t }, s) { for (; t;) { const n = t.subTree; if (n.suspense && n.suspense.activeBranch === e && (n.el = e.el), n === e) (e = t.vnode).el = s, t = t.parent; else break } } const Tr = e => e.__isSuspense; function mo(e, t) { t && t.pendingBranch ? R(e) ? t.effects.push(...e) : t.effects.push(e) : Ti(e) } const pe = Symbol.for("v-fgt"), Qt = Symbol.for("v-txt"), Ke = Symbol.for("v-cmt"), as = Symbol.for("v-stc"), vt = []; let ae = null; function Y(e = !1) { vt.push(ae = e ? null : []) } function bo() { vt.pop(), ae = vt[vt.length - 1] || null } let Ct = 1; function gn(e, t = !1) { Ct += e, e < 0 && ae && t && (ae.hasOnce = !0) } function Er(e) { return e.dynamicChildren = Ct > 0 ? ae || tt : null, bo(), Ct > 0 && ae && ae.push(e), e } function ce(e, t, s, n, r, i) { return Er(z(e, t, s, n, r, i, !0)) } function qs(e, t, s, n, r) { return Er(de(e, t, s, n, r, !0)) } function Or(e) { return e ? e.__v_isVNode === !0 : !1 } function dt(e, t) { return e.type === t.type && e.key === t.key } const Ar = ({ key: e }) => e ?? null, Nt = ({ ref: e, ref_key: t, ref_for: s }) => (typeof e == "number" && (e = "" + e), e != null ? J(e) || Q(e) || M(e) ? { i: Ce, r: e, k: t, f: !!s } : e : null); function z(e, t = null, s = null, n = 0, r = null, i = e === pe ? 0 : 1, o = !1, c = !1) { const u = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && Ar(t), ref: t && Nt(t), scopeId: rr, slotScopeIds: null, children: s, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: i, patchFlag: n, dynamicProps: r, dynamicChildren: null, appContext: null, ctx: Ce }; return c ? (zs(u, s), i & 128 && e.normalize(u)) : s && (u.shapeFlag |= J(s) ? 8 : 16), Ct > 0 && !o && ae && (u.patchFlag > 0 || i & 6) && u.patchFlag !== 32 && ae.push(u), u } const de = yo; function yo(e, t = null, s = null, n = 0, r = null, i = !1) { if ((!e || e === Ki) && (e = Ke), Or(e)) { const c = ot(e, t, !0); return s && zs(c, s), Ct > 0 && !i && ae && (c.shapeFlag & 6 ? ae[ae.indexOf(e)] = c : ae.push(c)), c.patchFlag = -2, c } if (Ro(e) && (e = e.__vccOpts), t) { t = vo(t); let { class: c, style: u } = t; c && !J(c) && (t.class = Ye(c)), V(u) && (Bs(u) && !R(u) && (u = re({}, u)), t.style = Ms(u)) } const o = J(e) ? 1 : Tr(e) ? 128 : Ai(e) ? 64 : V(e) ? 4 : M(e) ? 2 : 0; return z(e, t, s, n, r, o, i, !0) } function vo(e) { return e ? Bs(e) || pr(e) ? re({}, e) : e : null } function ot(e, t, s = !1, n = !1) { const { props: r, ref: i, patchFlag: o, children: c, transition: u } = e, h = t ? xo(r || {}, t) : r, a = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: h, key: h && Ar(h), ref: t && t.ref ? s && i ? R(i) ? i.concat(Nt(t)) : [i, Nt(t)] : Nt(t) : i, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: c, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== pe ? o === -1 ? 16 : o | 16 : o, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: u, component: e.component, suspense: e.suspense, ssContent: e.ssContent && ot(e.ssContent), ssFallback: e.ssFallback && ot(e.ssFallback), placeholder: e.placeholder, el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return u && n && Us(a, u.clone(a)), a } function Cs(e = " ", t = 0) { return de(Qt, null, e, t) } function Pr(e = "", t = !1) { return t ? (Y(), qs(Ke, null, e)) : de(Ke, null, e) } function Se(e) { return e == null || typeof e == "boolean" ? de(Ke) : R(e) ? de(pe, null, e.slice()) : Or(e) ? $e(e) : de(Qt, null, String(e)) } function $e(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : ot(e) } function zs(e, t) { let s = 0; const { shapeFlag: n } = e; if (t == null) t = null; else if (R(t)) s = 16; else if (typeof t == "object") if (n & 65) { const r = t.default; r && (r._c && (r._d = !1), zs(e, r()), r._c && (r._d = !0)); return } else { s = 32; const r = t._; !r && !pr(t) ? t._ctx = Ce : r === 3 && Ce && (Ce.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else M(t) ? (t = { default: t, _ctx: Ce }, s = 32) : (t = String(t), n & 64 ? (s = 16, t = [Cs(t)]) : s = 8); e.children = t, e.shapeFlag |= s } function xo(...e) { const t = {}; for (let s = 0; s < e.length; s++) { const n = e[s]; for (const r in n) if (r === "class") t.class !== n.class && (t.class = Ye([t.class, n.class])); else if (r === "style") t.style = Ms([t.style, n.style]); else if (qt(r)) { const i = t[r], o = n[r]; o && i !== o && !(R(i) && i.includes(o)) && (t[r] = i ? [].concat(i, o) : o) } else r !== "" && (t[r] = n[r]) } return t } function xe(e, t, s, n = null) { Ee(e, t, 7, [s, n]) } const wo = ar(); let So = 0; function Co(e, t, s) { const n = e.type, r = (t ? t.appContext : e.appContext) || wo, i = { uid: So++, vnode: e, type: n, parent: t, appContext: r, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new Jr(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(r.provides), ids: t ? t.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: _r(n, r), emitsOptions: Cr(n, r), emit: null, emitted: null, propsDefaults: K, inheritAttrs: n.inheritAttrs, ctx: K, data: K, props: K, attrs: K, slots: K, refs: K, setupState: K, setupContext: null, suspense: s, suspenseId: s ? s.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return i.ctx = { _: i }, i.root = t ? t.root : i, i.emit = ao.bind(null, i), e.ce && e.ce(i), i } let ne = null; const To = () => ne || Ce; let Wt, Ts; { const e = Gt(), t = (s, n) => { let r; return (r = e[s]) || (r = e[s] = []), r.push(n), i => { r.length > 1 ? r.forEach(o => o(i)) : r[0](i) } }; Wt = t("__VUE_INSTANCE_SETTERS__", s => ne = s), Ts = t("__VUE_SSR_SETTERS__", s => Tt = s) } const Ot = e => { const t = ne; return Wt(e), e.scope.on(), () => { e.scope.off(), Wt(t) } }, _n = () => { ne && ne.scope.off(), Wt(null) }; function Rr(e) { return e.vnode.shapeFlag & 4 } let Tt = !1; function Eo(e, t = !1, s = !1) { t && Ts(t); const { props: n, children: r } = e.vnode, i = Rr(e); Zi(e, n, i, t), to(e, r, s || t); const o = i ? Oo(e, t) : void 0; return t && Ts(!1), o } function Oo(e, t) { const s = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Ui); const { setup: n } = s; if (n) { Re(); const r = e.setupContext = n.length > 1 ? Po(e) : null, i = Ot(e), o = Et(n, e, 0, [e.props, r]), c = Mn(o); if (Me(), i(), (c || e.sp) && !bt(e) && ir(e), c) { if (o.then(_n, _n), t) return o.then(u => { mn(e, u) }).catch(u => { Xt(u, e, 0) }); e.asyncDep = o } else mn(e, o) } else Mr(e) } function mn(e, t, s) { M(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : V(t) && (e.setupState = Qn(t)), Mr(e) } function Mr(e, t, s) { const n = e.type; e.render || (e.render = n.render || Te); { const r = Ot(e); Re(); try { Vi(e) } finally { Me(), r() } } } const Ao = { get(e, t) { return k(e, "get", ""), e[t] } }; function Po(e) { const t = s => { e.exposed = s || {} }; return { attrs: new Proxy(e.attrs, Ao), slots: e.slots, emit: e.emit, expose: t } } function Js(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Qn(pi(e.exposed)), { get(t, s) { if (s in t) return t[s]; if (s in yt) return yt[s](e) }, has(t, s) { return s in t || s in yt } })) : e.proxy } function Ro(e) { return M(e) && "__vccOpts" in e } const Mo = (e, t) => vi(e, t, Tt), Io = "3.5.18";/**
* @vue/runtime-dom v3.5.18
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Es; const bn = typeof window < "u" && window.trustedTypes; if (bn) try { Es = bn.createPolicy("vue", { createHTML: e => e }) } catch { } const Ir = Es ? e => Es.createHTML(e) : e => e, Fo = "http://www.w3.org/2000/svg", Ho = "http://www.w3.org/1998/Math/MathML", Ae = typeof document < "u" ? document : null, yn = Ae && Ae.createElement("template"), Do = { insert: (e, t, s) => { t.insertBefore(e, s || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, s, n) => { const r = t === "svg" ? Ae.createElementNS(Fo, e) : t === "mathml" ? Ae.createElementNS(Ho, e) : s ? Ae.createElement(e, { is: s }) : Ae.createElement(e); return e === "select" && n && n.multiple != null && r.setAttribute("multiple", n.multiple), r }, createText: e => Ae.createTextNode(e), createComment: e => Ae.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => Ae.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, s, n, r, i) { const o = s ? s.previousSibling : t.lastChild; if (r && (r === i || r.nextSibling)) for (; t.insertBefore(r.cloneNode(!0), s), !(r === i || !(r = r.nextSibling));); else { yn.innerHTML = Ir(n === "svg" ? `<svg>${e}</svg>` : n === "mathml" ? `<math>${e}</math>` : e); const c = yn.content; if (n === "svg" || n === "mathml") { const u = c.firstChild; for (; u.firstChild;)c.appendChild(u.firstChild); c.removeChild(u) } t.insertBefore(c, s) } return [o ? o.nextSibling : t.firstChild, s ? s.previousSibling : t.lastChild] } }, $o = Symbol("_vtc"); function No(e, t, s) { const n = e[$o]; n && (t = (t ? [t, ...n] : [...n]).join(" ")), t == null ? e.removeAttribute("class") : s ? e.setAttribute("class", t) : e.className = t } const vn = Symbol("_vod"), jo = Symbol("_vsh"), Lo = Symbol(""), Bo = /(^|;)\s*display\s*:/; function Ko(e, t, s) { const n = e.style, r = J(s); let i = !1; if (s && !r) { if (t) if (J(t)) for (const o of t.split(";")) { const c = o.slice(0, o.indexOf(":")).trim(); s[c] == null && jt(n, c, "") } else for (const o in t) s[o] == null && jt(n, o, ""); for (const o in s) o === "display" && (i = !0), jt(n, o, s[o]) } else if (r) { if (t !== s) { const o = n[Lo]; o && (s += ";" + o), n.cssText = s, i = Bo.test(s) } } else t && e.removeAttribute("style"); vn in e && (e[vn] = i ? n.display : "", e[jo] && (n.display = "none")) } const xn = /\s*!important$/; function jt(e, t, s) { if (R(s)) s.forEach(n => jt(e, t, n)); else if (s == null && (s = ""), t.startsWith("--")) e.setProperty(t, s); else { const n = Uo(e, t); xn.test(s) ? e.setProperty(Ze(n), s.replace(xn, ""), "important") : e[n] = s } } const wn = ["Webkit", "Moz", "ms"], ds = {}; function Uo(e, t) { const s = ds[t]; if (s) return s; let n = Le(t); if (n !== "filter" && n in e) return ds[t] = n; n = Hn(n); for (let r = 0; r < wn.length; r++) { const i = wn[r] + n; if (i in e) return ds[t] = i } return t } const Sn = "http://www.w3.org/1999/xlink"; function Cn(e, t, s, n, r, i = zr(t)) { n && t.startsWith("xlink:") ? s == null ? e.removeAttributeNS(Sn, t.slice(6, t.length)) : e.setAttributeNS(Sn, t, s) : s == null || i && !Dn(s) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : Ue(s) ? String(s) : s) } function Tn(e, t, s, n, r) { if (t === "innerHTML" || t === "textContent") { s != null && (e[t] = t === "innerHTML" ? Ir(s) : s); return } const i = e.tagName; if (t === "value" && i !== "PROGRESS" && !i.includes("-")) { const c = i === "OPTION" ? e.getAttribute("value") || "" : e.value, u = s == null ? e.type === "checkbox" ? "on" : "" : String(s); (c !== u || !("_value" in e)) && (e.value = u), s == null && e.removeAttribute(t), e._value = s; return } let o = !1; if (s === "" || s == null) { const c = typeof e[t]; c === "boolean" ? s = Dn(s) : s == null && c === "string" ? (s = "", o = !0) : c === "number" && (s = 0, o = !0) } try { e[t] = s } catch { } o && e.removeAttribute(r || t) } function Vo(e, t, s, n) { e.addEventListener(t, s, n) } function Wo(e, t, s, n) { e.removeEventListener(t, s, n) } const En = Symbol("_vei"); function qo(e, t, s, n, r = null) { const i = e[En] || (e[En] = {}), o = i[t]; if (n && o) o.value = n; else { const [c, u] = zo(t); if (n) { const h = i[t] = Yo(n, r); Vo(e, c, h, u) } else o && (Wo(e, c, o, u), i[t] = void 0) } } const On = /(?:Once|Passive|Capture)$/; function zo(e) { let t; if (On.test(e)) { t = {}; let n; for (; n = e.match(On);)e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : Ze(e.slice(2)), t] } let hs = 0; const Jo = Promise.resolve(), Go = () => hs || (Jo.then(() => hs = 0), hs = Date.now()); function Yo(e, t) { const s = n => { if (!n._vts) n._vts = Date.now(); else if (n._vts <= s.attached) return; Ee(Xo(n, s.value), t, 5, [n]) }; return s.value = e, s.attached = Go(), s } function Xo(e, t) { if (R(t)) { const s = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { s.call(e), e._stopped = !0 }, t.map(n => r => !r._stopped && n && n(r)) } else return t } const An = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, Zo = (e, t, s, n, r, i) => { const o = r === "svg"; t === "class" ? No(e, n, o) : t === "style" ? Ko(e, s, n) : qt(t) ? As(t) || qo(e, t, s, n, i) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : ko(e, t, n, o)) ? (Tn(e, t, n), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && Cn(e, t, n, o, i, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !J(n)) ? Tn(e, Le(t), n, i, t) : (t === "true-value" ? e._trueValue = n : t === "false-value" && (e._falseValue = n), Cn(e, t, n, o)) }; function ko(e, t, s, n) { if (n) return !!(t === "innerHTML" || t === "textContent" || t in e && An(t) && M(s)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { const r = e.tagName; if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE") return !1 } return An(t) && J(s) ? !1 : t in e } const Qo = ["ctrl", "shift", "alt", "meta"], el = { stop: e => e.stopPropagation(), prevent: e => e.preventDefault(), self: e => e.target !== e.currentTarget, ctrl: e => !e.ctrlKey, shift: e => !e.shiftKey, alt: e => !e.altKey, meta: e => !e.metaKey, left: e => "button" in e && e.button !== 0, middle: e => "button" in e && e.button !== 1, right: e => "button" in e && e.button !== 2, exact: (e, t) => Qo.some(s => e[`${s}Key`] && !t.includes(s)) }, tl = (e, t) => { const s = e._withMods || (e._withMods = {}), n = t.join("."); return s[n] || (s[n] = (r, ...i) => { for (let o = 0; o < t.length; o++) { const c = el[t[o]]; if (c && c(r, t)) return } return e(r, ...i) }) }, sl = re({ patchProp: Zo }, Do); let Pn; function nl() { return Pn || (Pn = no(sl)) } const rl = (...e) => { const t = nl().createApp(...e), { mount: s } = t; return t.mount = n => { const r = ol(n); if (!r) return; const i = t._component; !M(i) && !i.render && !i.template && (i.template = r.innerHTML), r.nodeType === 1 && (r.textContent = ""); const o = s(r, !1, il(r)); return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), o }, t }; function il(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function ol(e) { return J(e) ? document.querySelector(e) : e } const ll = (e, t) => { const s = e.__vccOpts || e; for (const [n, r] of t) s[n] = r; return s }, cl = {}, fl = { xmlns: "http://www.w3.org/2000/svg", width: "50", height: "50", viewBox: "0 0 1024 1024" }; function ul(e, t) { return Y(), ce("svg", fl, t[0] || (t[0] = [z("path", { d: "M738.3 287.6H285.7c-59 0-106.8 47.8-106.8 106.8v303.1c0 59 47.8 106.8 106.8 106.8h81.5v111.1c0 .7.8 1.1 1.4.7l166.9-110.6 41.8-.8h117.4l43.6-.4c59 0 106.8-47.8 106.8-106.8V394.5c0-59-47.8-106.9-106.8-106.9zM351.7 448.2c0-29.5 23.9-53.5 53.5-53.5s53.5 23.9 53.5 53.5-23.9 53.5-53.5 53.5-53.5-23.9-53.5-53.5zm157.9 267.1c-67.8 0-123.8-47.5-132.3-109h264.6c-8.6 61.5-64.5 109-132.3 109zm110-213.7c-29.5 0-53.5-23.9-53.5-53.5s23.9-53.5 53.5-53.5 53.5 23.9 53.5 53.5-23.9 53.5-53.5 53.5zM867.2 644.5V453.1h26.5c19.4 0 35.1 15.7 35.1 35.1v121.1c0 19.4-15.7 35.1-35.1 35.1h-26.5zM95.2 609.4V488.2c0-19.4 15.7-35.1 35.1-35.1h26.5v191.3h-26.5c-19.4 0-35.1-15.7-35.1-35.1zM561.5 149.6c0 23.4-15.6 43.3-36.9 49.7v44.9h-30v-44.9c-21.4-6.5-36.9-26.3-36.9-49.7 0-28.6 23.3-51.9 51.9-51.9s51.9 23.3 51.9 51.9z" }, null, -1)])) } const Gs = ll(cl, [["render", ul]]), al = { class: "message-text" }, dl = { __name: "ChatMessage", props: { chat: { type: Object, required: !0 } }, setup(e) { return (t, s) => (Y(), ce("div", { class: Ye(["messageCon", `${e.chat.role === "model" ? "bot" : "user"}-message`]) }, [e.chat.role === "model" ? (Y(), qs(Gs, { key: 0 })) : Pr("", !0), z("p", al, Is(e.chat.text), 1)], 2)) } }, hl = { class: "chat-header" }, pl = { class: "header-info" }, gl = { __name: "ChatbotHeader", props: ["showChatbot"], emits: ["toggle"], setup(e, { emit: t }) { const s = t; return (n, r) => (Y(), ce("div", hl, [z("div", pl, [de(Gs), r[1] || (r[1] = z("h2", { class: "logo-text" }, "Changai", -1))]), z("button", { onClick: r[0] || (r[0] = i => s("toggle")), class: "material-symbols-rounded" }, "keyboard_arrow_down")])) } }, _l = { __name: "ChatForm", props: { setChatHistory: Function }, setup(e) { const t = e, s = Qe(null), n = () => { const r = s.value?.value.trim(); r && (t.setChatHistory(r), s.value.value = "") }; return (r, i) => (Y(), ce("form", { class: "chat-form", onSubmit: tl(n, ["prevent"]) }, [z("input", { ref_key: "inputRef", ref: s, type: "text", placeholder: "Message...", class: "message-input", required: "" }, null, 512), i[0] || (i[0] = z("button", { class: "material-symbols-rounded", type: "submit" }, "arrow_upward", -1))], 32)) } }, ml = { key: 0, class: "material-symbols-rounded" }, bl = { key: 1, class: "material-symbols-rounded" }, yl = { class: "chatbot-popup" }, vl = { class: "tab_box" }, xl = { key: 0 }, wl = { class: "messageCon bot-message" }, Sl = { key: 1 }, Cl = { key: 0 }, Tl = { class: "message-text" }, El = { key: 1, class: "message-text" }, Ol = { class: "chat-footer" }, Al = { __name: "App", setup(e) { const t = Qe(null), s = Qe(!1), n = Qe([]), r = Qe("chat"), i = Qe([]), o = async (h, a) => { const p = C => { n.value = [...n.value.filter(O => O.text !== "Thinking..."), { role: "model", text: C }] }, S = { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ qstn: a }) }; try { const C = await fetch("https://hyrin.erpgulf.com:7061/api/method/changai.changai.api.prediction_pipeline.fetch_data_from_server", S), O = await C.json(); if (!C.ok) { throw console.error("Backend Error Response:", O), new Error(O.message?.error || "Something went wrong!!"); throw new Error(`HTTP error! status: ${C.status}`) } console.log("Bot Response:", O); const I = O.message?.query_data || "No response from API"; p(I), i.value.push({ user: a, doctype: O.message?.doctype, top_fields: O.message?.top_fields, fields: O.message?.fields, query: O.message?.query, data: O.message?.data }), await u() } catch (C) { console.error("API Error:", C), n.value = [...n.value.filter(O => O.text !== "Thinking..."), { role: "model", text: C }], i.value.push({ user: a, error: C.message }) } }, c = async h => { n.value.push({ role: "user", text: h }), await ys(), u(), setTimeout(() => { n.value.push({ role: "model", text: "Thinking..." }), u(), o([...n.value, { role: "user", text: h }], h) }, 600) }, u = async () => { await ys(), t.value && t.value.scrollTo({ top: t.value.scrollHeight, behavior: "smooth" }) }; return (h, a) => (Y(), ce("div", { class: Ye(["app-container", { "show-chatbot": s.value }]) }, [z("button", { onClick: a[0] || (a[0] = p => s.value = !s.value), id: "chatbot-toggler" }, [s.value ? (Y(), ce("span", bl, "close")) : (Y(), ce("span", ml, "mode_comment"))]), z("div", yl, [de(gl, { showChatbot: s.value, onToggle: a[1] || (a[1] = p => s.value = !s.value) }, null, 8, ["showChatbot"]), z("div", vl, [z("button", { class: Ye(["tab_btn", { active: r.value === "chat" }]), onClick: a[2] || (a[2] = p => r.value = "chat") }, " Chat ", 2), z("button", { class: Ye(["tab_btn", { active: r.value === "debug" }]), onClick: a[3] || (a[3] = p => r.value = "debug") }, "Debug", 2)]), z("div", { class: "chat-body", ref_key: "chatBodyRef", ref: t }, [r.value === "chat" ? (Y(), ce("div", xl, [z("div", wl, [de(Gs), a[4] || (a[4] = z("p", { class: "message-text" }, [Cs(" Hello there!"), z("br"), Cs(" Iam Changai, your AI assistant. ")], -1))]), (Y(!0), ce(pe, null, on(n.value, (p, S) => (Y(), qs(dl, { key: S, chat: p }, null, 8, ["chat"]))), 128))])) : r.value === "debug" ? (Y(), ce("div", Sl, [i.value.length > 0 ? (Y(), ce("div", Cl, [(Y(!0), ce(pe, null, on(i.value, (p, S) => (Y(), ce("div", { key: S, class: "debug-query" }, [z("pre", Tl, Is(JSON.stringify(p, null, 2)), 1)]))), 128))])) : (Y(), ce("p", El, "No debug data yet."))])) : Pr("", !0)], 512), z("div", Ol, [de(_l, { setChatHistory: c })])])], 2)) } }; rl(Al).mount("#app");
